
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search Places and Rate</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        #map { height: 600px; width: 100%; }
        #place-details { margin-top: 20px; }
        .place-item { cursor: pointer; padding: 5px; border: 1px solid #ddd; margin-bottom: 5px; }
        .place-item:hover { background-color: #f9f9f9; }
        select, input, button { margin: 10px 0; padding: 5px; }
        #search-results { border: 1px solid #ccc; max-height: 150px; overflow-y: auto; margin-top: 5px; }
        .search-result { padding: 5px; cursor: pointer; }
        .search-result:hover { background-color: #e0e0e0; }
        .search-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 10px 0;
        }
        #error-message { color: red; margin-top: 10px; }
        #location-status { color: green; margin-top: 5px; font-size: 12px; }
    </style>
</head>
<body>
    <h1>Search Places and Rate</h1>
    <button id="locate-btn">Locate Me</button>
    <div id="location-status"></div>
    <div class="search-container">
        <label for="manual-location">Set Location Manually:</label>
        <input type="text" id="manual-location" placeholder="Enter location">
        <div id="search-results"></div>
    </div>
    <label for="tag">Search by Tag:</label>
    <select id="tag">
        <option value="restaurant">Restaurant</option>
        <option value="cafe">Cafe</option>
        <option value="bar">Bar</option>
        <option value="club">Club</option>
        <option value="shop">Shop</option>
    </select>
    <label for="ambiance">Select Ambiance:</label>
    <select id="ambiance">
        <option value="any">Any</option>
        <option value="chill">Chill</option>
        <option value="lively">Lively</option>
        <option value="romantic">Romantic</option>
        <option value="fun">Fun</option>
    </select>
    <label for="sort">Sort by:</label>
    <select id="sort">
        <option value="distance">Distance</option>
        <option value="reviews">Reviews</option>
    </select>
    <button id="search-btn">Search</button>
    <div id="error-message"></div>
    <div id="map"></div>
    <div id="place-details"></div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const map = L.map('map').setView([20.5937, 78.9629], 5);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);

            let userMarker = null;
            const placeMarkers = [];

            const locateBtn = document.getElementById('locate-btn');
            const manualLocationInput = document.getElementById('manual-location');
            const searchResultsContainer = document.getElementById('search-results');
            const errorMessage = document.getElementById('error-message');
            const locationStatus = document.getElementById('location-status');
            const tagSelect = document.getElementById('tag');
            const ambianceSelect = document.getElementById('ambiance');
            const sortSelect = document.getElementById('sort');
            const searchBtn = document.getElementById('search-btn');
            const placeDetails = document.getElementById('place-details');

            const geocoderApiKey = '2f30476331e54e569f1f4a926097e208';

            function displayError(message) {
                errorMessage.textContent = message;
                locationStatus.textContent = '';
                setTimeout(() => (errorMessage.textContent = ''), 5000);
            }

            function displayLocationStatus(message) {
                locationStatus.textContent = message;
                errorMessage.textContent = '';
                setTimeout(() => (locationStatus.textContent = ''), 3000);
            }

            function getCookie(name) {
                let cookieValue = null;
                if (document.cookie && document.cookie !== '') {
                    const cookies = document.cookie.split(';');
                    for (let i = 0; i < cookies.length; i++) {
                        const cookie = cookies[i].trim();
                        if (cookie.substring(0, name.length + 1) === (name + '=')) {
                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                            break;
                        }
                    }
                }
                return cookieValue;
            }

            // NEW: Function to update location in database
            function updateLocationInDB(lat, lon, source) {
                console.log(`Updating location in DB: lat=${lat}, lon=${lon}, source=${source}`);
                
                fetch('/update_location/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': getCookie('csrftoken'),
                    },
                    body: `latitude=${lat}&longitude=${lon}`
                })
                .then(response => response.json())
                .then(data => {
                    console.log('Location update response:', data);
                    if (data.status === 'success') {
                        displayLocationStatus(`Location updated in database! (${source})`);
                        console.log('Location successfully updated in DB!');
                    } else {
                        console.error('Failed to update location:', data.message);
                        displayError(`Failed to update location: ${data.message}`);
                    }
                })
                .catch(error => {
                    console.error('Error updating location:', error);
                    displayError('Error updating location in database');
                });
            }

            function addUserMarker(lat, lon, popupText = "You are here") {
                if (userMarker) {
                    userMarker.setLatLng([lat, lon]).setPopupContent(popupText).openPopup();
                } else {
                    userMarker = L.marker([lat, lon], { draggable: true })
                        .addTo(map)
                        .bindPopup(popupText)
                        .openPopup();

                    // UPDATED: Enhanced marker drag event with DB update
                    userMarker.on("dragend", function (e) {
                        const position = e.target.getLatLng();
                        map.setView([position.lat, position.lng], 15);
                        userMarker.setLatLng(position).setPopupContent("Location updated by dragging!").openPopup();
                        
                        // Update location in database when marker is dragged
                        updateLocationInDB(position.lat, position.lng, 'marker drag');
                    });
                }
            }

            // UPDATED: Enhanced locateUser function with DB update
            function locateUser() {
                displayLocationStatus('Getting your location...');
                
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const lat = position.coords.latitude;
                            const lon = position.coords.longitude;
                            map.setView([lat, lon], 15);
                            addUserMarker(lat, lon, "You are here");
                            
                            // NEW: Update location in database when "Locate Me" is clicked
                            updateLocationInDB(lat, lon, 'GPS location');
                            
                            //autoSearchNearby(lat, lon);
                        },
                        (error) => {
                            console.error('Geolocation error:', error);
                            displayError("Unable to access your location.");
                            fallbackGeoJS();
                        },
                        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                    );
                } else {
                    displayError("Geolocation not supported by this browser.");
                    fallbackGeoJS();
                }
            }

            // UPDATED: Enhanced fallback with DB update
            function fallbackGeoJS() {
                displayLocationStatus('Getting approximate location...');
                
                fetch("https://get.geojs.io/v1/ip/geo.json")
                    .then(res => res.json())
                    .then(data => {
                        const lat = parseFloat(data.latitude);
                        const lon = parseFloat(data.longitude);
                        map.setView([lat, lon], 12);
                        addUserMarker(lat, lon, "Approx. location via IP");
                        
                        // NEW: Update location in database for IP-based location
                        updateLocationInDB(lat, lon, 'IP geolocation');
                        
                        //autoSearchNearby(lat, lon);
                    })
                    .catch((error) => {
                        console.error('GeoJS error:', error);
                        displayError("Unable to fetch location from GeoJS.");
                    });
            }

            function displaySearchResults(results) {
                searchResultsContainer.innerHTML = '';
                if (results.length === 0) {
                    searchResultsContainer.innerHTML = '<p>No results found. Try refining your search.</p>';
                    return;
                }
                results.forEach((result) => {
                    const searchResult = document.createElement('div');
                    searchResult.className = 'search-result';
                    searchResult.textContent = result.place_name;
                    searchResult.addEventListener('click', () => {
                        const [lon, lat] = result.center;
                        manualLocationInput.value = result.place_name;
                        map.setView([lat, lon], 15);
                        addUserMarker(lat, lon, result.place_name);
                        searchResultsContainer.innerHTML = '';
                        
                        // NEW: Update location in database when manual location is selected
                        updateLocationInDB(lat, lon, 'manual search');
                        
                        autoSearchNearby(lat, lon);
                    });
                    searchResultsContainer.appendChild(searchResult);
                });
            }

            manualLocationInput.addEventListener('input', () => {
                const query = manualLocationInput.value.trim();
                if (query.length < 3) return;
                fetch(`https://api.geocoderapi.com/v1/autocomplete?text=${encodeURIComponent(query)}&apikey=${geocoderApiKey}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.results) {
                            displaySearchResults(data.results);
                        } else {
                            displayError("No results found.");
                        }
                    })
                    .catch(() => displayError("Error fetching location data."));
            });

            function clearPlaceMarkers() {
                placeMarkers.forEach(marker => map.removeLayer(marker));
                placeMarkers.length = 0;
                placeDetails.innerHTML = '';
            }

            function distance(lat1, lon1, lat2, lon2) {
                const R = 6371000;
                const toRad = x => x * Math.PI / 180;
                const dLat = toRad(lat2 - lat1);
                const dLon = toRad(lon2 - lon1);
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                          Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            async function fetchNearbyPlaces(lat, lon, tag) {
                const query = `
                    [out:json][timeout:25];
                    (
                      node["amenity"="${tag}"](around:1000,${lat},${lon});
                      way["amenity"="${tag}"](around:1000,${lat},${lon});
                      relation["amenity"="${tag}"](around:1000,${lat},${lon});
                    );
                    out center;
                `;
                const url = 'https://overpass-api.de/api/interpreter?data=' + encodeURIComponent(query);
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    return data.elements;
                } catch (error) {
                    displayError("Failed to fetch nearby places.");
                    return [];
                }
            }

            function displayPlaces(places, userLat, userLon) {
                clearPlaceMarkers();
                if (places.length === 0) {
                    placeDetails.innerHTML = '<p>No places found nearby.</p>';
                    return;
                }

                if (sortSelect.value === 'distance') {
                    places.sort((a, b) => {
                        const aDist = distance(userLat, userLon, a.lat || a.center.lat, a.lon || a.center.lon);
                        const bDist = distance(userLat, userLon, b.lat || b.center.lat, b.lon || b.center.lon);
                        return aDist - bDist;
                    });
                }

                places.forEach(place => {
                    const lat = place.lat || (place.center && place.center.lat);
                    const lon = place.lon || (place.center && place.center.lon);
                    const name = place.tags?.name || "Unnamed place";
                    const address = place.tags?.['addr:full'] || '';
                    const popupContent = `<b>${name}</b><br>${address}`;
                    const marker = L.marker([lat, lon]).addTo(map).bindPopup(popupContent);
                    placeMarkers.push(marker);
                    const div = document.createElement('div');
                    div.className = 'place-item';
                    div.textContent = name;
                    div.addEventListener('click', () => {
                        map.setView([lat, lon], 18);
                        marker.openPopup();
                    });
                    placeDetails.appendChild(div);
                });
            }

            async function autoSearchNearby(lat, lon) {
                const places = await fetchNearbyPlaces(lat, lon, tagSelect.value);
                displayPlaces(places, lat, lon);
            }

            searchBtn.addEventListener('click', () => {
                if (userMarker) {
                    const pos = userMarker.getLatLng();
                    autoSearchNearby(pos.lat, pos.lng);
                } else {
                    displayError("Please set your location first.");
                }
            });

            // UPDATED: Enhanced locate button event listener
            locateBtn.addEventListener('click', () => {
                console.log('Locate Me button clicked');
                locateUser();
            });

            setTimeout(() => {
                if (!userMarker) {
                    fallbackGeoJS();
                }
            }, 3000);
        });
    </script>
</body>
</html>

